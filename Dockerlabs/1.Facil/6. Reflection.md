# Write-up:

- **Nombre de la m√°quina:** `Reflection`
- **Plataforma:** `Dockerlabs`
- **IP:** `172.17.0.2`
- **SO:** `Linux`
- **Dificultad:** `F√°cil`

---

## 1. RECONOCIMIENTO üîç

El objetivo de esta fase es identificar los puntos de entrada y servicios expuestos en la m√°quina v√≠ctima.

#### 1.1. Verificaci√≥n de Conectividad

Se lanza un `ping` para confirmar que la m√°quina est√° activa y obtener el TTL, lo que nos da una primera pista sobre el sistema operativo.

```
ping 172.17.0.2
```

Nos devuelve conectividad y un **TTL=64**, lo que confirma que estamos ante una m√°quina **Linux**.

<p align="center">
    <img src="Imagenes/275.png" width="1000">
</p>

#### 1.2. Escaneo de Puertos

Se realiza un escaneo con **Nmap** para descubrir puertos abiertos, los servicios que corren en ellos y sus versiones.

```
sudo nmap -p- -sV -sC -sS --min-rate 5000 --open -n -Pn 172.17.0.2 -oN port_scan.txt
```

**Puertos Descubiertos:**

|**Puerto**|**Servicio**|**Versi√≥n**|**Notas**|
|---|---|---|---|
|22|ssh|OpenSSH 9.2|Necesitamos credenciales|
|80|http|Apache 2.4.62|Iniciaremos por aqu√≠|

<p align="center">
    <img src="Imagenes/276.png" width="1000">
</p>

El acceso por el puerto **22 (ssh)** requiere de credenciales, as√≠ que lo m√°s productivo es explorar el servicio **HTTP** en el puerto **80**.

---

## 2. ENUMERACI√ìN 

Una vez identificados los servicios, procedemos a investigarlos en profundidad en busca de vulnerabilidades o informaci√≥n √∫til.

### Puerto 80 (HTTP)

#### Enumeraci√≥n Manual:

- **Navegaci√≥n web:** Al visitar `http://172.17.0.2`, encontramos un _hub_ con **4 peque√±as pruebas de XSS (Cross-Site Scripting)**. 
    <p align="center">
    <img src="Imagenes/277.png" width="1000">
	</p>

**1. Laboratorio Reflejado (Reflected XSS - Input Box):**

Se introduce el _payload_ en la caja de texto para forzar la ejecuci√≥n del script.

HTML

```
<img src=x onerror=alert('XSS')>
```

El navegador intenta cargar una imagen inv√°lida (`src=x`), lo cual activa el evento **`onerror`**. Esto fuerza la ejecuci√≥n del c√≥digo JavaScript, que muestra la ventana emergente (`alert`), confirmando el √©xito del ataque de XSS reflejado.
<p align="center">
    <img src="Imagenes/278.png" width="1000">
</p>
<p align="center">
    <img src="Imagenes/279.png" width="1000">
</p>

**2. Laboratorio Almacenado (Stored XSS):**

Se introduce el mismo _payload_.

HTML

```
<img src=x onerror=alert('XSS')>
```

En este caso, el _payload_ malicioso se ha guardado en la aplicaci√≥n y se ejecutar√° autom√°ticamente en el navegador de **cualquier usuario** que visite la p√°gina que muestre ese contenido almacenado, sin necesidad de interacci√≥n adicional.



<p align="center">
    <img src="Imagenes/280.png" width="1000">
</p>
<p align="center">
    <img src="Imagenes/281.png" width="1000">
</p>

**3. Laboratorio con Dropdown :**

Observamos que al seleccionar una opci√≥n y enviar, el valor se refleja en la **URL**. Sustituimos el valor de la opci√≥n en la URL por nuestro _payload_. 
```
 <img src=x onerror=alert('XSS')>
```

**URL Original** 
<p align="center">
    <img src="Imagenes/282.png" width="1000">
</p>

**URL Modificada con Payload:**
<p align="center">
    <img src="Imagenes/283.png" width="1000">
</p>

Vemos c√≥mo el valor del campo pasa a reflejar y ejecutar el _script_.
<p align="center">
    <img src="Imagenes/284.png" width="1000">
</p>


**4. Laboratorio Reflected XSS a trav√©s de URL**

Notamos que la p√°gina est√° esperando un par√°metro. A√±adimos directamente el par√°metro `data` en la URL.
<p align="center">
    <img src="Imagenes/285.png" width="1000">
</p>

**URL original** 
<p align="center">
    <img src="Imagenes/294.png" width="1000">
</p>

**URL Modificada con Payload:** `http://172.17.0.2/reflected_url?data=<img src=x onerror=alert('XSS')>`
<p align="center">
    <img src="Imagenes/286.png" width="1000">
</p>
La inyecci√≥n es exitosa.
<p align="center">
    <img src="Imagenes/287.png" width="1000">
</p>

---

## 3. EXPLOTACI√ìN 

Al completar los cuatro laboratorios de XSS, se nos proporciona un _alert_ con las **credenciales SSH** necesarias para el siguiente paso.

<p align="center">
    <img src="Imagenes/288.png" width="1000">
</p>

**Credenciales obtenidas:**
- **Usuario:** `balu`
- **Contrase√±a:** `baurero`


### 3.1. Acceso Inicial (SSH)

Utilizamos las credenciales descubiertas para conectarnos al servicio **ssh** en el puerto 22.

```
ssh balu@172.17.0.2
```

<p align="center">
    <img src="Imagenes/289.png" width="1000">
</p>

---

## 4. ESCALADA DE PRIVILEGIOS ‚è´

Una vez dentro, el objetivo es elevar los privilegios del usuario actual (`balu`) al de `root`.

### 4.1. Enumeraci√≥n Interna

Se realizan comprobaciones b√°sicas en busca de posibles vectores de escalada.
#### Comprobaciones del sistema:

¬øQu√© usuario somos?
`whoami`
<p align="center">
    <img src="Imagenes/290.png" width="1000">
</p>


¬øQu√© usuario hay en el sistema con una shell?
```
cat /etc/passwd | grep sh
```
<p align="center">
    <img src="Imagenes/291.png" width="1000">
</p>

#### B√∫squeda del Vector de Escalada:

Revisamos los binarios con el **SUID** (Set User ID) establecido, que permiten a un usuario ejecutar un archivo con los permisos del propietario (en este caso, `root`).

```
find / -perm -4000 2>/dev/null
```

Entre los resultados, identificamos que el usuario `balu` puede ejecutar el binario **`/usr/bin/env`** como _root_ debido al permiso SUID.

>  <p align="center">
    <img src="Imagenes/292.png" width="1000">
</p>

Buscamos en **Gtfobins** la t√©cnica de escalada de privilegios para el binario `env` cuando tiene el _flag_ SUID.

**Referencia:** https://gtfobins.github.io/gtfobins/env/#suid


### 4.2. Explotaci√≥n y Escalada a Root

Ejecutamos el comando encontrado para obtener una _shell_ con privilegios de **root**.

```
/usr/bin/env /bin/sh -p
```


<p align="center">
    <img src="Imagenes/293.png" width="1000">
</p>

Somos  Root üöÄ
